{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"GitHub Repository Address Book Lambda","text":"<p>This site documents the Address Book Lambda that collects GitHub usernames, verified org emails, and account IDs, and writes JSON lookup files to S3 for use by Digital Landscape.</p> <ul> <li>What it does, how it works, and how to configure it</li> <li>How to run and develop locally</li> <li>FAQs and troubleshooting tips</li> </ul>"},{"location":"#what-the-address-book-lambda-function-does","title":"What the Address Book Lambda function does?","text":"<p>This Lambda function makes a request to GitHub to retrieve the usernames, organisation emails and account IDs for every ONS Digital GitHub user. This data is then organised into 3 dictionaries which are then put into the Digital Landscape AWS S3 bucket for later retrieval.</p>"},{"location":"#how-does-the-address-book-lambda-function-work","title":"How does the Address Book Lambda function work?","text":"<ul> <li>Authenticate with GitHub using GitHub App credentials provided via environment variables.</li> <li>Query the organisation via the GitHub GraphQL API (using <code>github-api-toolkit</code>) to retrieve GitHub usernames, verified org emails and account IDs.</li> <li>Build three dictionaries:</li> <li>username \u2192 list of verified org emails</li> <li>email \u2192 username</li> <li>username \u2192 GitHub account ID</li> <li>Write the JSON outputs to the placed in the S3 bucket under the <code>AddressBook/</code> prefix.</li> <li> <p>Log progress and errors; failures are visible in CloudWatch.</p> </li> <li> <p>Read more... The Process</p> </li> </ul> <p>Quick links:</p> <ul> <li>Technical Overview: Overview</li> <li>Pipeline: The Process</li> <li>Configuration: Configuration</li> <li>Logging: Logging</li> <li>Docs Usage: Documentation</li> </ul>"},{"location":"documentation/","title":"Documentation","text":"<p>This site uses MkDocs to build its documentation and GitHub Pages for hosting.</p>"},{"location":"documentation/#format","title":"Format","text":"<p>Documentation within this project follows the following pattern:</p> <ul> <li>A <code>README.md</code> for each component</li> <li>A <code>/docs</code> folder for the project</li> </ul> <p>Each <code>README.md</code> should contain:</p> <ul> <li>A description of what the component is/does</li> <li>A list of any prerequisites</li> <li>Setup instructions</li> <li>Execution instructions</li> <li>Deployment instructions</li> </ul> <p>The <code>/docs</code> folder should contain:</p> <ul> <li>A description of what the project is</li> <li>An overview of how the everything fits together in the project</li> <li>An explanation of the tech stack</li> <li>Details of the underlying dataset</li> </ul> <p>A majority of the information should reside within the <code>/docs</code> directory over the <code>README</code>. The <code>README</code>s in this project should be kept for concise instructions on how to use each component. Any detailed explanation should be kept within <code>/docs</code>.</p>"},{"location":"documentation/#getting-mkdocs-setup","title":"Getting MkDocs Setup","text":"<p>In order to build an MkDocs deployment or serve the documentation locally, we need to install MkDocs and its dependencies (Using Poetry).</p> <ol> <li> <p>Navigate into the project's root directory.</p> </li> <li> <p>Install MkDocs and its dependencies.</p> </li> </ol> <pre><code>make install-docs\n</code></pre> <ol> <li>You can now use MkDocs. To see a list of commands run the following:</li> </ol> <pre><code>mkdocs --help\n</code></pre> <p>Please Note: This project uses Poetry to install MkDocs and manage dependencies. Ensure you have Python and Poetry installed beforehand.</p>"},{"location":"documentation/#updating-mkdocs-deployment","title":"Updating MkDocs Deployment","text":""},{"location":"documentation/#github-action-to-deploy-documentation","title":"GitHub Action to Deploy Documentation","text":"<p>A GitHub Action is set up to automatically deploy the documentation to GitHub Pages whenever a commit is made to the <code>main</code> branch. This action is triggered by a push event to the <code>main</code> branch and runs the <code>mkdocs gh-deploy</code> command to build and deploy the documentation.</p>"},{"location":"documentation/#manual-deployment","title":"Manual Deployment","text":"<p>If changes are made within <code>/docs</code>, the GitHub Pages deployment will need to be updated. Assuming you have already installed MkDocs and Material for MkDocs, do the following:</p> <ol> <li> <p>Navigate to the projects root directory.</p> </li> <li> <p>Deploy the documentation to GitHub Pages.</p> </li> </ol> <pre><code>mkdocs gh-deploy\n</code></pre> <ol> <li>This will build the documentation and deploy it to the <code>gh-pages</code> branch of your repository. The documentation will be available at <code>https://ONS-Innovation.github.io/&lt;repository-name&gt;/</code>.</li> </ol> <p>Please Note: The <code>gh-deploy</code> command will overwrite the <code>gh-pages</code> branch and make the local changes available on GitHub Pages. Make sure that these changes are appropriate and have been reviewed before deployment.</p>"},{"location":"faq/","title":"FAQ","text":"<p>Below are common questions and quick fixes when using the Address Book Lambda.</p>"},{"location":"faq/#outputs-and-data","title":"Outputs and Data","text":""},{"location":"faq/#what-does-the-lambda-produce","title":"What does the Lambda produce?","text":"<ul> <li>Three JSON files in S3 under the <code>AddressBook/</code> prefix:</li> <li><code>addressBookUsernameKey.json</code>: username \u2192 list of verified org emails</li> <li><code>addressBookEmailKey.json</code>: email \u2192 username</li> <li><code>addressBookIDKey.json</code>: username \u2192 GitHub account ID</li> </ul>"},{"location":"faq/#how-often-does-the-lambda-run","title":"How often does the Lambda run?","text":"<ul> <li>The schedule is controlled by EventBridge via Terraform variables in <code>terraform/service/env/*/*.tfvars</code>.</li> </ul>"},{"location":"faq/#where-are-the-files-written","title":"Where are the files written?","text":"<ul> <li>To the bucket specified by <code>S3_BUCKET_NAME</code>, under the <code>AddressBook/</code> prefix.</li> </ul>"},{"location":"faq/#why-are-some-users-missing-email-addresses","title":"Why are some users missing email addresses?","text":"<ul> <li>Only verified organisation emails are included by design. Users without a verified org email won\u2019t appear in the email-based mappings.</li> </ul>"},{"location":"faq/#documentation-mkdocs","title":"Documentation (MkDocs)","text":""},{"location":"faq/#make-mkdocs-serve-fails-or-pages-404","title":"<code>make mkdocs-serve</code> fails or pages 404.","text":"<ul> <li>The target is <code>docs-serve</code>, not <code>mkdocs-serve</code>. Also ensure <code>mkdocs.yml</code> nav matches files in <code>docs/</code>.</li> </ul> <p>For a deeper dive, see:</p> <ul> <li>Overview</li> <li>The Process</li> <li>Configuration</li> </ul>"},{"location":"technical_documentation/api_github_services/","title":"GitHub Services (API)","text":"<p>Encapsulates interactions with the GitHub GraphQL API using <code>github_api_toolkit</code> and a GitHub App installation token.</p>"},{"location":"technical_documentation/api_github_services/#overview","title":"Overview","text":"<ul> <li>Retrieves a GitHub App installation token via AWS Secrets Manager (<code>AWS_SECRET_NAME</code>) and the provided <code>GITHUB_APP_CLIENT_ID</code>.</li> <li>Builds a GraphQL client interface for requests.</li> <li>Provides <code>get_all_user_details()</code> which returns:</li> <li><code>user_to_email</code>: username \u2192 list of verified org emails</li> <li><code>email_to_user</code>: email \u2192 username</li> <li><code>user_to_id</code>: username \u2192 GitHub account ID</li> <li>Or a tuple <code>(\"NotFound\", &lt;message&gt;)</code> if the org is missing/inaccessible.</li> </ul>"},{"location":"technical_documentation/api_github_services/#quick-start","title":"Quick Start","text":"<pre><code>import boto3\nfrom github_services import GitHubServices\nfrom logger import wrapped_logging\n\nlogger = wrapped_logging(False)\nsm = boto3.client(\"secretsmanager\")\n\nsvc = GitHubServices(\n    org=\"&lt;org&gt;\",\n    logger=logger,\n    secret_manager=sm,\n    secret_name=\"&lt;aws_secret_name&gt;\",\n    app_client_id=\"&lt;github_app_client_id&gt;\",\n)\n\nresult = svc.get_all_user_details()\nif isinstance(result, tuple) and result[0] == \"NotFound\":\n    logger.log_error(f\"Org issue: {result[1]}\")\nelse:\n    user_to_email, email_to_user, user_to_id = result\n</code></pre>"},{"location":"technical_documentation/api_github_services/#notes","title":"Notes","text":"<ul> <li>Skips members with no verified org emails and logs a warning.</li> <li>Paginates through org members in batches of 100.</li> <li>Errors retrieving tokens or invalid secrets raise exceptions.</li> </ul>"},{"location":"technical_documentation/api_github_services/#reference","title":"Reference","text":""},{"location":"technical_documentation/api_github_services/#github_services.GitHubServices","title":"<code>GitHubServices</code>","text":"Source code in <code>src/github_services.py</code> <pre><code>class GitHubServices:\n    def __init__(\n        self,\n        org: str,\n        logger: Any,\n        secret_manager: Any,\n        secret_name: str,\n        app_client_id: str,\n    ):\n        \"\"\"\n        Initialises the GitHub Services Class\n\n        Raises:\n            Exception: if GitHub app installation token is not found\n\n        Args:\n            org - Organisation name\n            logger - The Lambda functions logger\n            secret_manager - The S3 secrets manager\n            secret_name - Secret name for AWS\n            app_client_id - GitHub App Client ID\n        \"\"\"\n\n        self.org = org\n        self.logger = logger\n\n        token = self.get_access_token(secret_manager, secret_name, app_client_id)\n\n        # Ensure we have a valid token tuple before proceeding\n        if not isinstance(token, tuple):\n            self.logger.log_error(\n                f\"Failed to retrieve GitHub App installation token: {token}\"\n            )\n            raise Exception(str(token))\n\n        access_token = token[0]\n\n        self.ql = github_api_toolkit.github_graphql_interface(access_token)\n\n    def get_access_token(\n        self, secret_manager: Any, secret_name: str, app_client_id: str\n    ) -&gt; Tuple[str, str]:\n        \"\"\"Gets the access token from the AWS Secret Manager.\n\n        Args:\n            secret_manager (Any): The Boto3 Secret Manager client.\n            secret_name (str): The name of the secret to get.\n            app_client_id (str): The client ID of the GitHub App.\n\n        Raises:\n            Exception: If the secret is not found in the Secret Manager.\n            Exception: if GitHub app installation token is not found\n\n        Returns:\n            str: GitHub token.\n        \"\"\"\n        response = secret_manager.get_secret_value(SecretId=secret_name)\n\n        pem_contents = response.get(\"SecretString\", \"\")\n\n        if not pem_contents:\n            error_message = f\"Secret {secret_name} not found in AWS Secret Manager. Please check your environment variables.\"\n            self.logger.log_error(error_message)\n            raise Exception(error_message)\n\n        token = github_api_toolkit.get_token_as_installation(\n            self.org, pem_contents, app_client_id\n        )\n\n        if not isinstance(token, tuple):\n            self.logger.log_error(\n                f\"Failed to retrieve GitHub App installation token: {token}\"\n            )\n            raise Exception(str(token))\n\n        return token\n\n    def get_all_user_details(self) -&gt; tuple[dict, dict, dict] | tuple:\n        \"\"\"\n        Retrieve all the usernames within the GitHub organisation\n\n        Returns:\n            list(dict) - members usernames, emails and account ids\n        \"\"\"\n\n        user_to_email = {}\n        email_to_user = {}\n        user_to_id = {}\n        has_next_page = True\n        cursor = None\n\n        while has_next_page:\n            query = \"\"\"\n                query ($org: String!, $cursor: String) {\n                    organization(login: $org) {\n                        membersWithRole(first: 100, after: $cursor) {\n                            pageInfo {\n                                hasNextPage\n                                endCursor\n                            }\n                            nodes {\n                                login\n                                databaseId\n                                organizationVerifiedDomainEmails(login: $org)\n                            }\n                        }\n                    }\n                }\n            \"\"\"\n\n            params = {\"org\": self.org, \"cursor\": cursor}\n\n            # Use instance-aware request (passes headers/token and has fallback)\n            response_json = self.ql.make_ql_request(query, params).json()\n\n            org_data = response_json.get(\"data\", {}).get(\"organization\")\n\n            if not org_data:\n                org_error_message = (\n                    f\"Organisation '{self.org} not found or inaccessible'\"\n                )\n                self.logger.log_error(org_error_message)\n                return (\"NotFound\", org_error_message)\n\n            members_conn = org_data.get(\"membersWithRole\", {})\n            page_info = members_conn.get(\"pageInfo\", {})\n            has_next_page = page_info.get(\"hasNextPage\", False)\n            cursor = page_info.get(\"endCursor\")\n\n            for node in members_conn.get(\"nodes\", []):\n                username = node.get(\"login\")\n                account_id = node.get(\"databaseId\")\n                emails = node.get(\"organizationVerifiedDomainEmails\", [])\n\n                if not username:\n                    self.logger.log_warning(\"Skipping member with empty username\")\n                    continue\n\n                if emails == [] or not emails:\n                    self.logger.log_warning(\n                        f\"Skipping member '{username}' with no verified domain emails\"\n                    )\n                    continue\n\n                user_to_email[username] = emails\n                if account_id is not None:\n                    user_to_id[username] = account_id\n                for address in emails:\n                    email_to_user[address] = username\n\n        return user_to_email, email_to_user, user_to_id\n</code></pre>"},{"location":"technical_documentation/api_github_services/#github_services.GitHubServices.__init__","title":"<code>__init__(org, logger, secret_manager, secret_name, app_client_id)</code>","text":"<p>Initialises the GitHub Services Class</p> <p>Raises:</p> Type Description <code>Exception</code> <p>if GitHub app installation token is not found</p> Source code in <code>src/github_services.py</code> <pre><code>def __init__(\n    self,\n    org: str,\n    logger: Any,\n    secret_manager: Any,\n    secret_name: str,\n    app_client_id: str,\n):\n    \"\"\"\n    Initialises the GitHub Services Class\n\n    Raises:\n        Exception: if GitHub app installation token is not found\n\n    Args:\n        org - Organisation name\n        logger - The Lambda functions logger\n        secret_manager - The S3 secrets manager\n        secret_name - Secret name for AWS\n        app_client_id - GitHub App Client ID\n    \"\"\"\n\n    self.org = org\n    self.logger = logger\n\n    token = self.get_access_token(secret_manager, secret_name, app_client_id)\n\n    # Ensure we have a valid token tuple before proceeding\n    if not isinstance(token, tuple):\n        self.logger.log_error(\n            f\"Failed to retrieve GitHub App installation token: {token}\"\n        )\n        raise Exception(str(token))\n\n    access_token = token[0]\n\n    self.ql = github_api_toolkit.github_graphql_interface(access_token)\n</code></pre>"},{"location":"technical_documentation/api_github_services/#github_services.GitHubServices.get_access_token","title":"<code>get_access_token(secret_manager, secret_name, app_client_id)</code>","text":"<p>Gets the access token from the AWS Secret Manager.</p> <p>Parameters:</p> Name Type Description Default <code>secret_manager</code> <code>Any</code> <p>The Boto3 Secret Manager client.</p> required <code>secret_name</code> <code>str</code> <p>The name of the secret to get.</p> required <code>app_client_id</code> <code>str</code> <p>The client ID of the GitHub App.</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>If the secret is not found in the Secret Manager.</p> <code>Exception</code> <p>if GitHub app installation token is not found</p> <p>Returns:</p> Name Type Description <code>str</code> <code>Tuple[str, str]</code> <p>GitHub token.</p> Source code in <code>src/github_services.py</code> <pre><code>def get_access_token(\n    self, secret_manager: Any, secret_name: str, app_client_id: str\n) -&gt; Tuple[str, str]:\n    \"\"\"Gets the access token from the AWS Secret Manager.\n\n    Args:\n        secret_manager (Any): The Boto3 Secret Manager client.\n        secret_name (str): The name of the secret to get.\n        app_client_id (str): The client ID of the GitHub App.\n\n    Raises:\n        Exception: If the secret is not found in the Secret Manager.\n        Exception: if GitHub app installation token is not found\n\n    Returns:\n        str: GitHub token.\n    \"\"\"\n    response = secret_manager.get_secret_value(SecretId=secret_name)\n\n    pem_contents = response.get(\"SecretString\", \"\")\n\n    if not pem_contents:\n        error_message = f\"Secret {secret_name} not found in AWS Secret Manager. Please check your environment variables.\"\n        self.logger.log_error(error_message)\n        raise Exception(error_message)\n\n    token = github_api_toolkit.get_token_as_installation(\n        self.org, pem_contents, app_client_id\n    )\n\n    if not isinstance(token, tuple):\n        self.logger.log_error(\n            f\"Failed to retrieve GitHub App installation token: {token}\"\n        )\n        raise Exception(str(token))\n\n    return token\n</code></pre>"},{"location":"technical_documentation/api_github_services/#github_services.GitHubServices.get_all_user_details","title":"<code>get_all_user_details()</code>","text":"<p>Retrieve all the usernames within the GitHub organisation</p> <p>Returns:</p> Type Description <code>tuple[dict, dict, dict] | tuple</code> <p>list(dict) - members usernames, emails and account ids</p> Source code in <code>src/github_services.py</code> <pre><code>def get_all_user_details(self) -&gt; tuple[dict, dict, dict] | tuple:\n    \"\"\"\n    Retrieve all the usernames within the GitHub organisation\n\n    Returns:\n        list(dict) - members usernames, emails and account ids\n    \"\"\"\n\n    user_to_email = {}\n    email_to_user = {}\n    user_to_id = {}\n    has_next_page = True\n    cursor = None\n\n    while has_next_page:\n        query = \"\"\"\n            query ($org: String!, $cursor: String) {\n                organization(login: $org) {\n                    membersWithRole(first: 100, after: $cursor) {\n                        pageInfo {\n                            hasNextPage\n                            endCursor\n                        }\n                        nodes {\n                            login\n                            databaseId\n                            organizationVerifiedDomainEmails(login: $org)\n                        }\n                    }\n                }\n            }\n        \"\"\"\n\n        params = {\"org\": self.org, \"cursor\": cursor}\n\n        # Use instance-aware request (passes headers/token and has fallback)\n        response_json = self.ql.make_ql_request(query, params).json()\n\n        org_data = response_json.get(\"data\", {}).get(\"organization\")\n\n        if not org_data:\n            org_error_message = (\n                f\"Organisation '{self.org} not found or inaccessible'\"\n            )\n            self.logger.log_error(org_error_message)\n            return (\"NotFound\", org_error_message)\n\n        members_conn = org_data.get(\"membersWithRole\", {})\n        page_info = members_conn.get(\"pageInfo\", {})\n        has_next_page = page_info.get(\"hasNextPage\", False)\n        cursor = page_info.get(\"endCursor\")\n\n        for node in members_conn.get(\"nodes\", []):\n            username = node.get(\"login\")\n            account_id = node.get(\"databaseId\")\n            emails = node.get(\"organizationVerifiedDomainEmails\", [])\n\n            if not username:\n                self.logger.log_warning(\"Skipping member with empty username\")\n                continue\n\n            if emails == [] or not emails:\n                self.logger.log_warning(\n                    f\"Skipping member '{username}' with no verified domain emails\"\n                )\n                continue\n\n            user_to_email[username] = emails\n            if account_id is not None:\n                user_to_id[username] = account_id\n            for address in emails:\n                email_to_user[address] = username\n\n    return user_to_email, email_to_user, user_to_id\n</code></pre>"},{"location":"technical_documentation/api_lambda_function/","title":"Lambda Handler (API)","text":"<p>The Lambda handler controls the address book run: reads configuration, authenticates to GitHub, gathers user details, and writes three JSON lookup files to S3.</p>"},{"location":"technical_documentation/api_lambda_function/#overview","title":"Overview","text":"<ul> <li>Reads env vars: <code>GITHUB_ORG</code>, <code>AWS_SECRET_NAME</code>, <code>GITHUB_APP_CLIENT_ID</code>, <code>S3_BUCKET_NAME</code>.</li> <li>Creates Boto3 clients for Secrets Manager and S3.</li> <li>Uses <code>GitHubServices.get_all_user_details()</code> to retrieve:</li> <li>username \u2192 verified org emails</li> <li>email \u2192 username</li> <li>username \u2192 GitHub account ID</li> <li>Writes JSON outputs under <code>AddressBook/</code> prefix to the configured S3 bucket.</li> <li>Logs progress and errors via <code>wrapped_logging</code>.</li> </ul>"},{"location":"technical_documentation/api_lambda_function/#local-run-development","title":"Local Run (development)","text":"<pre><code>export GITHUB_ORG=&lt;org&gt;\nexport AWS_SECRET_NAME=&lt;secret_name&gt;\nexport GITHUB_APP_CLIENT_ID=&lt;client_id&gt;\nexport S3_BUCKET_NAME=&lt;bucket_name&gt;\nexport AWS_ACCESS_KEY_ID=&lt;access_key&gt;\nexport AWS_SECRET_ACCESS_KEY=&lt;secret_key&gt;\n\npoetry run python3 src/lambda_function.py\n</code></pre>"},{"location":"technical_documentation/api_lambda_function/#responses","title":"Responses","text":"<ul> <li>200: success with <code>user_entries</code> count</li> <li>404: organisation not found</li> <li>500: missing configuration or S3 write failure</li> </ul>"},{"location":"technical_documentation/api_lambda_function/#reference","title":"Reference","text":"<p>AWS Lambda handler for the KEH Test Data Generator</p>"},{"location":"technical_documentation/api_lambda_function/#lambda_function.lambda_handler","title":"<code>lambda_handler(event, context)</code>","text":"<p>AWS Lambda handler function for generating synthetic test data.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <p>Input event data (dict)</p> required <code>context</code> <p>Lambda context object</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>If secret manager or s3client are None</p> <code>Exception</code> <p>If the environmental variables are not found</p> <code>Exception</code> <p>If there was a failure writing to S3</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>Response with statusCode and generated data</p> Source code in <code>src/lambda_function.py</code> <pre><code>def lambda_handler(event, context):\n    \"\"\"\n    AWS Lambda handler function for generating synthetic test data.\n\n    Args:\n        event: Input event data (dict)\n        context: Lambda context object\n\n    Raises:\n        Exception: If secret manager or s3client are None\n        Exception: If the environmental variables are not found\n        Exception: If there was a failure writing to S3\n\n    Returns:\n        dict: Response with statusCode and generated data\n    \"\"\"\n\n    org = os.getenv(\"GITHUB_ORG\")\n    secret_name = os.getenv(\"AWS_SECRET_NAME\")\n    app_client_id = os.getenv(\"GITHUB_APP_CLIENT_ID\")\n    bucket_name = os.getenv(\"S3_BUCKET_NAME\")\n\n    logger = wrapped_logging(False)\n\n    try:\n        secret_manager = boto3.client(\"secretsmanager\")\n        s3_client = boto3.client(\"s3\")\n    except Exception:\n        secret_manager = None\n        s3_client = None\n\n    if secret_manager is None or s3_client is None:\n        message = f\"Unable to retrieve Secret Manager ({'empty' if secret_manager is None else 'Not empty'}) or S3Client({'empty' if secret_manager is None else 'Not empty'})\"\n        logger.log_error(message)\n        raise Exception(message)\n\n    github_services = GitHubServices(\n        org, logger, secret_manager, secret_name, app_client_id\n    )\n    s3writer = S3Writer(logger, s3_client, bucket_name)\n\n    # Fetch data from GitHub\n    try:\n        response = github_services.get_all_user_details()\n\n        if response[0] == \"NotFound\":\n            return {\n                \"statusCode\": 404,\n                \"body\": json.dumps(\n                    {\n                        \"message\": \"Organisation not found\",\n                        \"error\": str(response[1]),\n                    }\n                ),\n            }\n        else:\n            user_to_email, email_to_user, user_to_id = response\n\n    except Exception as e:\n        raise Exception(\n            f\"Failed to fetch data from GitHub: {str(e)}. Are the environment variables set correctly?\"\n        )\n\n    # Serialize and write to S3\n    try:\n        username_key = \"addressBookUsernameKey.json\"\n        email_key = \"addressBookEmailKey.json\"\n        id_key = \"addressBookIDKey.json\"\n        folder = \"AddressBook/\"\n\n        s3writer.write_data_to_s3(\n            folder + username_key, json.dumps(user_to_email, indent=2)\n        )\n        s3writer.write_data_to_s3(\n            folder + email_key, json.dumps(email_to_user, indent=2)\n        )\n        s3writer.write_data_to_s3(folder + id_key, json.dumps(user_to_id, indent=2))\n    except Exception as e:\n        raise Exception(f\"Failed to write data to S3: {str(e)}\")\n\n    return {\n        \"statusCode\": 200,\n        \"body\": json.dumps(\n            {\n                \"message\": \"Successfully generated and stored address book data\",\n                \"user_entries\": len(user_to_email),\n            }\n        ),\n    }\n</code></pre>"},{"location":"technical_documentation/api_logger/","title":"Logger (API)","text":"<p>Thin wrapper around Python\u2019s <code>logging</code> providing simple <code>info</code>, <code>warning</code>, and <code>error</code> methods.</p>"},{"location":"technical_documentation/api_logger/#overview","title":"Overview","text":"<ul> <li>Class: <code>wrapped_logging(debug: bool)</code></li> <li>Methods:</li> <li><code>log_info(message: str)</code></li> <li><code>log_warning(message: str)</code></li> <li><code>log_error(message: str)</code></li> <li>Default level is <code>INFO</code>. When <code>debug=True</code>, a local <code>debug.log</code> file is written (development only).</li> </ul>"},{"location":"technical_documentation/api_logger/#quick-start","title":"Quick Start","text":"<pre><code>from logger import wrapped_logging\n\nlogger = wrapped_logging(False)\nlogger.log_info(\"Starting run\")\nlogger.log_warning(\"No verified emails for user\")\nlogger.log_error(\"Failed to write S3 object\")\n</code></pre>"},{"location":"technical_documentation/api_logger/#reference","title":"Reference","text":"<p>A python class which wraps the logging module to make testing easier.</p>"},{"location":"technical_documentation/api_logger/#logger.wrapped_logging","title":"<code>wrapped_logging</code>","text":"Source code in <code>src/logger.py</code> <pre><code>class wrapped_logging:\n    def __init__(self, debug: bool) -&gt; None:\n        \"\"\"Initialises the logger.\n        Args:\n            debug (bool): Whether to output debug logs.\n        \"\"\"\n        self.logger = logging.getLogger(__name__)\n        self.logger.setLevel(logging.INFO)\n\n        if debug:\n            logging.basicConfig(filename=\"debug.log\", filemode=\"w\")\n\n    def log_info(self, message: str) -&gt; None:\n        \"\"\"Logs an info message to the logger.\n        Args:\n            message (str): The message to log.\n        \"\"\"\n        self.logger.info(message)\n\n    def log_error(self, message: str) -&gt; None:\n        \"\"\"Logs an error message to the logger.\n        Args:\n            message (str): The message to log.\n        \"\"\"\n        self.logger.error(message)\n\n    def log_warning(self, message: str) -&gt; None:\n        \"\"\"Logs a warning message to the logger.\n        Args:\n            message (str): The message to log.\n        \"\"\"\n        self.logger.warning(message)\n</code></pre>"},{"location":"technical_documentation/api_logger/#logger.wrapped_logging.__init__","title":"<code>__init__(debug)</code>","text":"<p>Initialises the logger. Args:     debug (bool): Whether to output debug logs.</p> Source code in <code>src/logger.py</code> <pre><code>def __init__(self, debug: bool) -&gt; None:\n    \"\"\"Initialises the logger.\n    Args:\n        debug (bool): Whether to output debug logs.\n    \"\"\"\n    self.logger = logging.getLogger(__name__)\n    self.logger.setLevel(logging.INFO)\n\n    if debug:\n        logging.basicConfig(filename=\"debug.log\", filemode=\"w\")\n</code></pre>"},{"location":"technical_documentation/api_logger/#logger.wrapped_logging.log_error","title":"<code>log_error(message)</code>","text":"<p>Logs an error message to the logger. Args:     message (str): The message to log.</p> Source code in <code>src/logger.py</code> <pre><code>def log_error(self, message: str) -&gt; None:\n    \"\"\"Logs an error message to the logger.\n    Args:\n        message (str): The message to log.\n    \"\"\"\n    self.logger.error(message)\n</code></pre>"},{"location":"technical_documentation/api_logger/#logger.wrapped_logging.log_info","title":"<code>log_info(message)</code>","text":"<p>Logs an info message to the logger. Args:     message (str): The message to log.</p> Source code in <code>src/logger.py</code> <pre><code>def log_info(self, message: str) -&gt; None:\n    \"\"\"Logs an info message to the logger.\n    Args:\n        message (str): The message to log.\n    \"\"\"\n    self.logger.info(message)\n</code></pre>"},{"location":"technical_documentation/api_logger/#logger.wrapped_logging.log_warning","title":"<code>log_warning(message)</code>","text":"<p>Logs a warning message to the logger. Args:     message (str): The message to log.</p> Source code in <code>src/logger.py</code> <pre><code>def log_warning(self, message: str) -&gt; None:\n    \"\"\"Logs a warning message to the logger.\n    Args:\n        message (str): The message to log.\n    \"\"\"\n    self.logger.warning(message)\n</code></pre>"},{"location":"technical_documentation/api_s3writer/","title":"S3 Writer (API)","text":"<p>Writes JSON data to the configured S3 bucket and logs success/failure.</p>"},{"location":"technical_documentation/api_s3writer/#overview","title":"Overview","text":"<ul> <li>Constructor requires: <code>logger</code>, <code>s3_client</code> (boto3), and <code>bucket_name</code>.</li> <li>Validates <code>bucket_name</code> is set; otherwise raises <code>ValueError</code>.</li> <li>Method <code>write_data_to_s3(file_to_update, data)</code> uploads JSON to <code>s3://&lt;bucket&gt;/&lt;file_to_update&gt;</code>.</li> </ul>"},{"location":"technical_documentation/api_s3writer/#quick-start","title":"Quick Start","text":"<pre><code>import boto3, json\nfrom s3writer import S3Writer\nfrom logger import wrapped_logging\n\nlogger = wrapped_logging(False)\ns3 = boto3.client(\"s3\")\n\nwriter = S3Writer(logger, s3, bucket_name=\"&lt;bucket&gt;\")\n\npayload = {\"alice\": [\"alice@org.com\"], \"bob\": [\"bob@org.com\"]}\nwriter.write_data_to_s3(\"AddressBook/addressBookUsernameKey.json\", payload)\n</code></pre>"},{"location":"technical_documentation/api_s3writer/#errors","title":"Errors","text":"<ul> <li>Raises <code>Exception</code> if <code>file_to_update</code> or <code>data</code> is <code>None</code>.</li> <li>Logs errors and re-raises on S3 failures (e.g., access denied).</li> </ul>"},{"location":"technical_documentation/api_s3writer/#reference","title":"Reference","text":"<p>This file contains the S3Writer class to weekly upload the GitHub usernames and ONS emails to S3</p> <p>Typical usage example:</p> <pre><code>s3writer = S3Writer(logger)\ns3writer.write_data_to_s3(file_to_update, data) # These are the filename of the updated file and its contents respectively\n</code></pre>"},{"location":"technical_documentation/api_s3writer/#s3writer.S3Writer","title":"<code>S3Writer</code>","text":"<p>A class for uploading updated GitHub username and ONS emails to an AWS S3 Bucket</p> <p>This class provides a setup and then can be used for all uploading throughout the programs lifecycle.</p> Atrributes <p>s3_resrouce: The established 'session' or connection to AWS servers bucket_name: The name of the bucket to store the new JSON files logger: The variable which connects to the logger class</p> <p>Methods:</p> Name Description <code>write_data_to_s3</code> <p>Allows the program to connect to the S3 bucket and upload the JSON</p> Source code in <code>src/s3writer.py</code> <pre><code>class S3Writer:\n    \"\"\"\n    A class for uploading updated GitHub username and ONS emails to an AWS S3 Bucket\n\n    This class provides a setup and then can be used for all uploading throughout the programs lifecycle.\n\n    Atrributes:\n        s3_resrouce: The established 'session' or connection to AWS servers\n        bucket_name: The name of the bucket to store the new JSON files\n        logger: The variable which connects to the logger class\n\n    Methods:\n        write_data_to_s3: Allows the program to connect to the S3 bucket and upload the JSON\n    \"\"\"\n\n    def __init__(self, logger, s3_client, bucket_name):\n        \"\"\"\n        Initialises the S3Writer.\n        \"\"\"\n        self.logger = logger\n        self.s3_client = s3_client\n\n        # Load bucket name from environment variable\n        self.bucket_name = bucket_name\n        if not self.bucket_name:\n            raise ValueError(\n                \"S3_BUCKET_NAME environment variable is not set.\"\n                \"Please create a .env file with S3_BUCKET_NAME=your-bucket-name\"\n            )\n\n    def write_data_to_s3(\n        self, file_to_update: str | None, data: dict[str, Any] | str | None\n    ):\n        \"\"\"\n        Writes the data to a specific filename within the specificed s3 bucket\n\n        Args:\n            file_to_update: Name of the file to update within S3\n            data: Contents of the new and updated file\n\n            Raises:\n            Exception: If filename or data is empty\n            Exception: If S3 update fails\n        \"\"\"\n\n        # Ensure that the arguments are not None\n        if file_to_update is None or data is None:\n            message = f\"filename or data is empty. filename: {'empty' if file_to_update is None else 'filled'}, data: {'empty' if data is None else 'filled'}\"\n            self.logger.log_error(message)\n            raise Exception(message)\n\n        # Convert dict to JSON string if needed\n        if isinstance(data, dict):\n            data_str = json.dumps(data, indent=2)\n        else:\n            data_str = data\n\n        # Upload the file to S3 within the bucket directly\n        key = f\"{file_to_update}\"\n\n        try:\n\n            self.s3_client.put_object(\n                Bucket=self.bucket_name,\n                Key=key,\n                Body=(\n                    data_str.encode(\"utf-8\")\n                    if isinstance(data_str, str)\n                    else json.dumps(data_str).encode(\"utf-8\")\n                ),\n                ContentType=\"application/json\",\n            )\n\n        except Exception as error:\n            self.logger.log_error(\n                f\"Unable to upload updated username and email data to S3, {error}\"\n            )\n            raise error\n        else:\n            self.logger.log_info(\n                \"Successfully uploaded updated username and email data to S3\"\n            )\n</code></pre>"},{"location":"technical_documentation/api_s3writer/#s3writer.S3Writer.__init__","title":"<code>__init__(logger, s3_client, bucket_name)</code>","text":"<p>Initialises the S3Writer.</p> Source code in <code>src/s3writer.py</code> <pre><code>def __init__(self, logger, s3_client, bucket_name):\n    \"\"\"\n    Initialises the S3Writer.\n    \"\"\"\n    self.logger = logger\n    self.s3_client = s3_client\n\n    # Load bucket name from environment variable\n    self.bucket_name = bucket_name\n    if not self.bucket_name:\n        raise ValueError(\n            \"S3_BUCKET_NAME environment variable is not set.\"\n            \"Please create a .env file with S3_BUCKET_NAME=your-bucket-name\"\n        )\n</code></pre>"},{"location":"technical_documentation/api_s3writer/#s3writer.S3Writer.write_data_to_s3","title":"<code>write_data_to_s3(file_to_update, data)</code>","text":"<p>Writes the data to a specific filename within the specificed s3 bucket</p> <p>Parameters:</p> Name Type Description Default <code>file_to_update</code> <code>str | None</code> <p>Name of the file to update within S3</p> required <code>data</code> <code>dict[str, Any] | str | None</code> <p>Contents of the new and updated file</p> required <code>Raises</code> required <code>Exception</code> <p>If filename or data is empty</p> required <code>Exception</code> <p>If S3 update fails</p> required Source code in <code>src/s3writer.py</code> <pre><code>def write_data_to_s3(\n    self, file_to_update: str | None, data: dict[str, Any] | str | None\n):\n    \"\"\"\n    Writes the data to a specific filename within the specificed s3 bucket\n\n    Args:\n        file_to_update: Name of the file to update within S3\n        data: Contents of the new and updated file\n\n        Raises:\n        Exception: If filename or data is empty\n        Exception: If S3 update fails\n    \"\"\"\n\n    # Ensure that the arguments are not None\n    if file_to_update is None or data is None:\n        message = f\"filename or data is empty. filename: {'empty' if file_to_update is None else 'filled'}, data: {'empty' if data is None else 'filled'}\"\n        self.logger.log_error(message)\n        raise Exception(message)\n\n    # Convert dict to JSON string if needed\n    if isinstance(data, dict):\n        data_str = json.dumps(data, indent=2)\n    else:\n        data_str = data\n\n    # Upload the file to S3 within the bucket directly\n    key = f\"{file_to_update}\"\n\n    try:\n\n        self.s3_client.put_object(\n            Bucket=self.bucket_name,\n            Key=key,\n            Body=(\n                data_str.encode(\"utf-8\")\n                if isinstance(data_str, str)\n                else json.dumps(data_str).encode(\"utf-8\")\n            ),\n            ContentType=\"application/json\",\n        )\n\n    except Exception as error:\n        self.logger.log_error(\n            f\"Unable to upload updated username and email data to S3, {error}\"\n        )\n        raise error\n    else:\n        self.logger.log_info(\n            \"Successfully uploaded updated username and email data to S3\"\n        )\n</code></pre>"},{"location":"technical_documentation/logging/","title":"Logging","text":"<p>Logging is implemented via a wrapper around Python\u2019s <code>logging</code> module in <code>src/logger.py</code>.</p>"},{"location":"technical_documentation/logging/#api","title":"API","text":"<p>Class: <code>wrapped_logging(debug: bool)</code></p> <ul> <li><code>log_info(message: str)</code>: log at INFO.</li> <li><code>log_error(message: str)</code>: log at ERROR.</li> <li><code>log_warning(message: str)</code>: log at WARNING.</li> </ul> <p>Behaviour:</p> <ul> <li>Default level is <code>INFO</code>.</li> <li>When <code>debug=True</code>, <code>logging.basicConfig(filename=\"debug.log\", filemode=\"w\")</code> writes a debug file locally (useful during development).</li> </ul>"},{"location":"technical_documentation/logging/#usage","title":"Usage","text":"<pre><code>from logger import wrapped_logging\n\nlogger = wrapped_logging(False)  # use True to write debug.log locally\n\nlogger.log_info(\"Start address book run\")\nlogger.log_warning(\"No verified emails for user: alice\")\nlogger.log_error(\"Failed to write to S3: access denied\")\n</code></pre> <p>In the Lambda handler (<code>src/lambda_function.py</code>), the logger is created once and passed to helpers:</p> <pre><code>logger = wrapped_logging(False)\n</code></pre>"},{"location":"technical_documentation/logging/#cloudwatch-logs","title":"CloudWatch Logs","text":"<ul> <li>Lambda automatically forwards stdout/stderr from Python logging to CloudWatch Logs for the function.</li> <li>Use logs to track: start/end of runs, GitHub API calls, S3 writes, and errors.</li> </ul>"},{"location":"technical_documentation/logging/#best-practices","title":"Best Practices","text":"<ul> <li>Prefer INFO for milestones, WARNING for recoverable anomalies, ERROR for failures.</li> <li>Add context to messages (org, bucket, key) to aid debugging.</li> <li>Avoid writing secrets or sensitive personal data to logs.</li> <li>For local dev, consider <code>debug=True</code> to capture a <code>debug.log</code>, but disable before committing.</li> </ul>"},{"location":"technical_documentation/overview/","title":"Overview","text":"<p>This Lambda queries the GitHub GraphQL API for all members of the configured organisation, collects their verified org email addresses and account IDs, and writes three S3 JSON lookup files used by Digital Landscape.</p> <p>Outputs (under <code>AddressBook/</code> in S3):</p> <ul> <li><code>addressBookUsernameKey.json</code>: username \u2192 list of verified org emails</li> <li><code>addressBookEmailKey.json</code>: email \u2192 username</li> <li><code>addressBookIDKey.json</code>: username \u2192 GitHub account ID</li> </ul> <p>See The Process.</p>"},{"location":"technical_documentation/overview/#purpose","title":"Purpose","text":"<p>Provide reliable lookups between GitHub usernames, verified organisation email addresses, and GitHub account IDs so Digital Landscape can identify owners quickly and consistently.</p>"},{"location":"technical_documentation/overview/#file-description","title":"File Description","text":"<ul> <li><code>src/lambda_function.py</code>: Orchestrates the run and writes outputs to S3.</li> <li><code>src/github_services.py</code>: Interfaces with GitHub GraphQL via <code>github-api-toolkit</code>.</li> <li><code>src/s3writer.py</code>: Handles writing JSON files to S3.</li> <li><code>src/logger.py</code>: Structured logging for observability.</li> </ul>"},{"location":"technical_documentation/overview/#outputs","title":"Outputs","text":"<p>S3 key prefix: <code>AddressBook/</code></p> <p>Example shapes:</p> <p><code>AddressBook/addressBookUsernameKey.json</code></p> <pre><code>{\n  \"alice\": [\"alice@org.com\", \"alice2@org.com\"],\n  \"bob\": [\"bob@org.com\"]\n}\n</code></pre> <p><code>AddressBook/addressBookEmailKey.json</code></p> <pre><code>{\n  \"alice@org.com\": \"alice\",\n  \"bob@org.com\": \"bob\"\n}\n</code></pre> <p><code>AddressBook/addressBookIDKey.json</code></p> <pre><code>{\n  \"alice\": 101,\n  \"bob\": 202\n}\n</code></pre>"},{"location":"technical_documentation/overview/#limitations-assumptions","title":"Limitations &amp; Assumptions","text":"<ul> <li>Only verified organisation emails are included in mappings.</li> <li>Subject to GitHub API rate limits; the implementation handles normal org sizes.</li> </ul>"},{"location":"technical_documentation/overview/#next-steps","title":"Next Steps","text":"<ul> <li>Read the detailed flow: The Process</li> <li>Configure environment and IAM: Configuration</li> </ul>"},{"location":"technical_documentation/the_process/","title":"The Process","text":"<ol> <li>Authenticate with GitHub via GitHub App credentials (env vars).</li> <li>Query the organisation members via GraphQL using <code>github-api-toolkit</code>.</li> <li>Build username\u2194email mappings and username\u2192id mapping.</li> <li>Write three JSON files to the configured S3 bucket under <code>AddressBook/</code>.</li> <li>Log progress and errors; failures surface in CloudWatch.</li> </ol> <p>See Configuration for required environment variables.</p>"},{"location":"technical_documentation/the_process/#detailed-steps","title":"Detailed Steps","text":"<ul> <li>Initialise logging and read required environment variables.</li> <li>Establish GitHub App authentication and create GraphQL requests (via <code>github-api-toolkit</code>).</li> <li>Retrieve organisation members and their verified organisation email addresses and account IDs, using pagination.</li> <li>Build three dictionaries:</li> <li>username \u2192 list of verified org emails</li> <li>email \u2192 username</li> <li>username \u2192 GitHub account ID</li> <li>Convert the dictionaries to JSON.</li> <li>Write JSON files to S3 under the <code>AddressBook/</code> prefix.</li> </ul>"},{"location":"technical_documentation/the_process/#key-components","title":"Key Components","text":"<ul> <li><code>src/lambda_function.py</code>: Orchestrates the run and calls downstream helpers.</li> <li><code>src/github_services.py</code>: Handles GitHub GraphQL interactions via <code>github-api-toolkit</code>.</li> <li><code>src/s3writer.py</code>: Writes JSON outputs to S3.</li> <li><code>src/logger.py</code>: Provides structured logging.</li> </ul>"},{"location":"technical_documentation/the_process/#error-handling-observability","title":"Error Handling &amp; Observability","text":"<ul> <li>All major steps are logged; inspect CloudWatch Logs for failures or anomalies.</li> <li>Ensure the Lambda role has <code>s3:PutObject</code> to the target bucket/prefix; access issues will surface during S3 writes.</li> <li>Verify GitHub App installation and credentials if API calls fail.</li> </ul>"},{"location":"technical_documentation/the_process/#outputs","title":"Outputs","text":"<ul> <li>Files are written to S3 under the <code>AddressBook/</code> prefix:</li> <li><code>addressBookUsernameKey.json</code></li> <li><code>addressBookEmailKey.json</code></li> <li><code>addressBookIDKey.json</code></li> </ul> <p>Return to the overview: Overview or dive deeper into configuration: Configuration.</p>"}]}